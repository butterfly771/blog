## 题整理

[TOC]

https://www.nowcoder.com/discuss/509963?type=2&order=3&pos=17&page=1&channel=1009&source_id=discuss_tag



### HTTP

#### 1.  请简单说一下对http协议和Tcp协议的了解

首先， Http协议是建立在Tcp协议基础上的。 
http协议位于应用层， 主要解决包转数据的问题， tcp协议位于传输层， 主要解决的数据如何在网络中传输的问题
当用户发起一次请求的时候, http会通过tcp建立起一次连接。
当请求的数据传输完毕之后， http会立即将tcp连接断开。 所以http也是一种短连接， 一种无状态的连接。



#### 2. 说一下对HTTP缓存的了解

主要分为强缓存和协商缓存。

强缓存有： 

- cache-control 相对时间
- expires

协商缓存有：

- [Etag, If-None-Match]:

  Etag: Etag就像一个指纹， 资源的变化会导致ETag的变化， ETag可以保证每个资源都是唯一的

  If-None-Match: 会将上次服务端返回的Etag发送给服务端，询问改资源是否有更新， 有变动的话会把

  新的资源返回回来

- [Last-Modified, If-Modified-Since]: 

  Last-Modified： 资源最后修改的时间

  If-Modified-Sinec: 上次返回的Last-Modified的值



#### 3. HTTP是如何建立连接的， 三次握手的过程？

通过三次握手建立连接, 

三次握手的过程。 

1. 客户端发送一个SYN字段， 并指明客户端的初始序列号， 即ISN。 确定客户端的发送能力和服务端的接受能力是正常的。
2. 服务端返回自己的SYN字段， 同样指明自己的ISN。同时为了确认客户端的SYN， 将ISC+1作为ACK的值， 如果丢失了， 就重传。确认了服务端的发送能力和接受能力是正常的。客户端的接受能力也是正常的。
3. 第三次握手。为了确认服务器端的SYN, 客户端将ISN+1作为ACK的值返回服务器端。客户端发包， 服务端收到了。 确认了 双方的发送能力和接受能力都是正常的。 就可以建立链接正常通信了



#### 4. HTTP是如何断开连接的， 四次挥手的过程？

通过四次挥手断开连接

四次挥手的过程

1. 客户端发送一个FIN端， 同时包含一个ACK,  表示确认对方最近发送过来的数据
2. 服务端将K值+1作为ACK的标志， 表明收到了上一个包。 这是上层的应用会被告知另一端发起了关闭操作。 通常这将引起应用程序发起自己的关闭操作
3. 服务端发起自己的FIN端， ACK=K+1,Seq=L
4. 客户端确认 ACK=L+1



#### 5. 为什么建立连接是3次握手， 断开连接需要四次握手

服务端在LISTEN的状态下， 收到建立链接的SYN报文后, 把ACK和SYN放到一个报文里发送给客户端。

而关闭链接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了。

但是还能接受数据。

HTTP是否现在关闭发送数据通道， 需要上层应用来决定，

 因此， 己方ACK和FIN一般都会分开发送，



#### 6.  Https与Http的区别

主要有以下几点区别

   1. HTTPS把HTTP上层的传输协议由TCP/IP换成了SSL/TLS

   2. HTTPS发送报文不再使用专门的Socket API, 而是调用专门的安全接口

   3. HTTPS需要去专门的机构申请到CA证书， 一般免费的证书很少， 都需要交费。

   4. HTTP是超文本传输协议，信息都是明文传输。HTTPS是具有安全性的ssl加密传输协议

   5. HTTP和HTTPS使用完全不同的连接方式， 采用的端口也不一样， HTTP是80， HTTPS采用的是443

   6. HTTP的连接很简单，是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议

      比HTTP要安全。

      

#### 7. 说一下对HTTP2的了解

1. HTTP2采用二进制格式进行传输数据。 而非HTTP1.X使用的文本格式。

2. HTTP2的传输的每个数据都是以消息的形式进行传输，而消息又由一个或多个帧组成

   最后使用流标示进行重新组装

3. 同域名下的只需要占用一个TCP连接。



#### 9. 什么是HTTP队头堵塞， 怎么解决？

其实就是排队问题。 HTTP协议遵循一发一收的规则，从而形成了一个先进先出的队列。

如果最开始请求没有处理完。 那么后面的请求响应都会处在等待状态。

如何解决？

1. 更换为HTTP2协议

   http2中，每个请求和响应都被称为消息。 每个消息被拆分为若干个帧进行传输。 每个帧又由多个流组成。

   每个流都会分配一个序号。 各个帧和流在连接上都进行独立传输。 到达之后在按照序号进行组装， 这样就解决了

   队头堵塞的问题。



#### 10. 什么是TCP队头堵塞， 怎么解决？

TCP的队头堵塞是指在传输的过程中， 其中一个分节的字段丢失， 后续的分节数据会被接收端一直保持， 知道丢失的数据重新

传递到接受端为止

如何解决？

1. 更换为udp协议



#### 11. 对Udp协议的了解

1. udp一样是位于传输层的协议， 主要是为了解决数据的传输问题。
2. Udp无连接， 不存在建立连接需要等待的时间 
3. udp没有拥塞控制，网络的波动不会影响源主机的发送
4. 支持一对一， 一对多， 多对多发送消息
5. udp面相数据报文， 数据之间不会有阻塞约束。



#### 12. HTTPS建立连接的过程？

主要分为以下几步：

1. 浏览器发送一个请求到服务器端

2. 服务器端向用户发送自己的数字证书， 证书中有一个公钥来加密信息，私钥由服务器持有

3. 客户端收到数组证书后， 回去检查数字证书的安全性和真伪性

   之后呢， 客户端会发送给服务器一个随机字符串给服务器的私钥进行加密。

   客户端使用公钥进行解密。 如果解密后的随机字符串一致。

   说明对方确实是私钥的真正持有者

4. 验证了服务器的身份之后， 可会断会生成一个对称加密算法和密钥。 客户端用公钥

   加密后发送给服务器端。 服务器端用私钥对加密算法和密钥进行解密， 之后可以进行通信。



#### 13. TCP如何在网络卡顿的时候不丢包？

1. 重试策略
2. *TCP* 的拥塞控制算法会在*丢包*时主动降低吞吐量



#### 14. TCP是如何进行分包的？



#### 15. Dns查询的过程，dns用什么协议发起dns查询的

以udp协议为主， 主要的查询协议是基于udp的，

但是在进行区域传输的时候会使用TCP协议。

拓展：  什么场景下面会需要进行数据传输？

DNS的规范规定了2种类型的DNS服务器，一个叫主DNS服务器，一个叫辅助DNS服务器。在一个区中主DNS服务器从自己本机的数据文件中读取该区的DNS数据信息，而辅助DNS服务器则从区的主DNS服务器中读取该区的DNS数据信息。当一个辅助DNS服务器启动时，它需要与主DNS服务器通信，并加载数据信息，这就叫做区传送（zone transfer）。 



### 网络安全

#### 1. 你都了解那些加密算法， 能简单说一下吗？

- 摘要加密

  使用hash函数对消息或文本进行加密和计算, 比如说`md5`和`sha`

- 对称加密

  双方使用同一个密钥和逆算法对消息进行加密和解密, 例如`des`和`aes`

- 非对称加密

  公钥和私钥都可以对消息进行加密，一方加密，另一方既可以解密。

  公钥无法推导出私钥。 所以公钥可以公开。私钥必须持有

  比如说rsa

#### 2. 说一下前端的一些攻击和防御手段。

- XSS跨站脚本攻击

  在一些表单中动态输入时，创建HTML标签元素， 将攻击的代码嵌入到服务器或者数据库中。

  发送给用户。

  解决方案： 处理尖括号

- CSRF跨站请求伪造

  网站B窃取了网站A的cookie，借助网站A中已经登陆的用户发起请求。

  进行一些危险的攻击和动作

  解决方案： 检查referer, 添加校验token, 不保存cookie, 不实用全局cookie

  自定义header头并且校验。

- injection注入



### 浏览器相关

#### 1. 能介绍一下浏览器的事件循环吗？ 

#### 2. 从输入url到页面加载发生了什么

1. DNS解析， 会从浏览器的缓存开始到顶级跟服务器， 查到到当前域名对应的ip和端口号服务

2. 建立TCP连接。 HTTP通过3次握手，HTTPS通过验证证书，发送密钥和公钥确认身份建立连接

3. 发送请求。接受请求， 处理请求

   - 缓存中获取请求内容
   - 服务端返回请求内容

4. 解析页面。

   - 构建渲染树

     解析html(边下载边解析), 解析css

   - 构建布局树， 更新元素的位置

   - 构建分层树， 处理一些滚动之类的， position， z-index等属性

   - 解析js： 重绘： 更新样式和属性。重排： 更新位置

     事件循环

   

#### 3. 解析CSS会阻塞dom解析吗？

不会， css的解析只会阻塞dom的渲染， 不会阻塞dom的解析



#### 4. cookie的samesite属性作用

通过限制第三方的cookie， 来防治CSRF攻击和用户追踪

- Strict： 完全禁止
- Lax： 大多数情况下不发送cookie
- None： 默认设置



### Javascript相关

#### 1. 说一下commonJs和esModule的区别

- commonJs是被加载时运行，esModule是编译的时候运行

- commonJs输出的是值的拷贝， esModule输出的是值的引用

- commJS具有缓存，被加载时会运行整个文件并输出一个对象。拷贝在内存中。

  下次加载文件时，直接从内存中取值

- esModule支持Tree-shaking



#### 2. js的数据结构？

基本数据类型： 

Number, Boolean, String, Undefined, Null

引用数据类型：

Object, Array, Function

Es6: 

Set, Map



#### 3. js的继承

- 构造函数继承

  ```
  ClassA.prototype =  new ClassB()
  ```

  问题： 子类new出来的实例， 父类的属性会项目影响没有隔离（应用类型）

  ```js
  function Parent2() {
    this.name = 'parent2'
    this.arr = [1, 2, 3]
  }
  Parent2.prototype.say = function () {
  	console.log(this.name)
  }
  function Child2() {
    this.type = 'child2'
  }
  Child2.prototype = new Parent2() //原型继承核心代码
  let child2_1 = new Child2()
  let child2_2 = new Child2()
  
  console.log(child2_1.name) // parent2
  console.log(child2_1.say()) // parent2
  child2_1.arr.push(4)
  console.log(child2_1.arr, child2_2.arr) // [1, 2, 3, 4]  [1, 2, 3, 4]
  ```

- 原型链继承

  ![](https://tva1.sinaimg.cn/large/0081Kckwly1gl7exnp0baj30ze082t99.jpg)

  问题： 方法需要在构造函数中创建， 无法复用，造成内存浪费

- 组合继承

  子类构造函数中调用父类的构造函数， 同时将子类的prototype指向父类

  ![](https://tva1.sinaimg.cn/large/0081Kckwly1gl7ez0elbjj310c0k6gnx.jpg)

  问题： 调用两次父类的构造函数

- 寄生式继承

  ![](https://tva1.sinaimg.cn/large/0081Kckwly1gl7ezwavq2j30zs0qgjtx.jpg)



#### 4. 数组和链表的区别

1. 数组在内存中是一块连续的区域， 但是链表可以存在于内存中的任意地方

2. 数组需要事先定义长度，需要预留出相应大小的内存， 如果需要拓展内存， 需要重新去进行分配， 效率很低

   但是链表不指定大小，拓展更方便

3. 链表增加或删除数据容易，查找元素复杂。 数组增加或插入元素效率更低， 但是查找元素的效率会更高



#### 5. FragmentDocument跟一次性渲染有什么不同



#### 6. 实现一个原声的Promise



#### 7. 手写bind函数

bind函数调用

```js
func.bind(this, ...args)
```

实现一个bind函数

```js
Function.prototype.myBind = function(context=window, ...preArgs) {
  return (...args) => {
    this.apply(context, [...preArgs, ...args])
  }
}
```



#### 8. 实现一个new函数

分析一下new函数的一个作用

通过new函数创建一个类的实例， 

- 实例可以访问在构造函数中定义的属性
- 实例也可以访问类的prototype中的属性
- 运行contructor函数

那么来实现一个new

```js
function objectFactory() {
  var obj = new Object();
  Contructor = [].shift.call(arguments);
  obj.__proto__ = Contructor.prototype;
  let ret = Contructor.apply(obj, arguments)
  return typeof ret === 'object' ? ret : obj
}
```



### React相关

#### 1. setState是同步还是异步？

在不同场景中处理方式不同， 可能是同步也可能是一步的

- 在合成事件中是异步的
- 声明周期中调用是异步的
- 原生事件是同步的
- setTimeout中是同步的
- 批量更新中还是异步的



#### 2. React 16中的生命周期

- constructor挂载

- getDerivedStateFromProps--prop更新的时候
- render渲染函数
- getSnapshotBeforeUpdate 触发commit之前，也可以读取dom
- componentDidUpdate ComponenetWillUpdate componentWillUnMount--Commit阶段触发



#### 3. diff算法

- treeDiff
- compinentDiff
- elementDiff



#### 4. 调用setState之后发生了什么

1. 在 `setState` 的时候，React 会为当前节点创建一个 `updateQueue` 的更新列队。
2. 然后会触发 `reconciliation` 过程，在这个过程中，会使用名为 Fiber 的调度算法，开始生成新的 Fiber 树， Fiber 算法的最大特点是可以做到异步可中断的执行。
3. 然后 `React Scheduler` 会根据优先级高低，先执行优先级高的节点，具体是执行 `doWork` 方法。
4. 在 `doWork` 方法中，React 会执行一遍 `updateQueue` 中的方法，以获得新的节点。然后对比新旧节点，为老节点打上 更新、插入、替换 等 Tag。
5. 当前节点 `doWork` 完成后，会执行 `performUnitOfWork` 方法获得新节点，然后再重复上面的过程。
6. 当所以节点都 `doWork` 完成后，会触发 `commitRoot` 方法，React 进入 commit 阶段。
7. 在 commit 阶段中，React 会根据前面为各个节点打的 Tag，一次性更新整个 dom 元素。



#### 5. react16的渲染过程

首先， react16采用了一个fiber架构， 整个渲染过程在concurrent模式下的渲染过程

是可中断的， 可调和的， 简单说一下他的核心过程吧

- 用户调用render方法，创建一个virtruldom树，生成一个root节点的fiber

- 模拟了requestIdCallback， 跟浏览器进行调和的方式， 调用workLoop方法

  对每个fiber单元进行处理。

- beginWork方法依次对不同的fiber单元进行处理,

  - 跟节点，文字节点， 原生节点， classComponent, FunctionComponent等

- reconcileChildren，处理当前fiber单元的孩子，生成对应的fiber节点，

  如果存在alternate,  复用之前的alternate

- fiber解析完成， 生成effectList链表

- commit阶段， 处理所有的effect副作用，比如说新增，删除，更新

react还采用了双缓冲的机制

- 第一次更新会建立current树
- 第二次更新呢， 建立alternate树， 缓存上一次的更新
- 第三次更新，workInprogress就指向了上一次更新的alternate树， 即第一次更新的树



#### 6. 常用的react Hooks

1. useState
2. useEffect --- 用来模拟各个生命周期函数的
   - componentDidMount  --> 第二个参数为空数组
   - componentWillUpdate --> 第二个参数是一个状态数据， 数据改变的时候，会触发更新
   - componentWillUnMount --> 第一个参数return一个函数
3. useRef --- 与组件进行关联

```

```

4. useContext -- 设置全局状态

   使用方法

   - 使用`C = createContext(initial)`创建上下文
   - 使用`<C.provider>`圈定作用域
   - 在作用域内使用`useContext(C)`来使用上下文

5. useReducer -- 模拟redux

6. useMemo 缓存复杂的计算值

   ```js
   function App() {
     const [n, setN] = React.useState(0);
     const [m, setM] = React.useState(0);
     const onClick = () => {
       setN(n + 1);
     };
     const onClickChild = useMemo(() => () => {}, [m]);
     return (
       <div className="App">
         <div>
           <button onClick={onClick}>update n {n}</button>
         </div>
         <Child data={m} onClick={onClickChild} />
       </div>
     );
   }
   
   const Child = React.memo(props => {
     console.log("child 执行了");
     return <div onClick={props.onClick}>child: {props.data}</div>;
   });
   ```

7. useCallback 缓存一个函数传递给子组件

8. useImperativeHandle 组件ref



#### 7. 简单说一下Vue和React的区别

1. 渲染方式不同： 数据改变， react需要重上到下重新比对。vue则是把每个渲染单元拆的足够小， 基于响应式的原理，实现了只更新数据变化的那个组件 
2. 架构不同： Vue核心是composition API和Proxy代理， React基于fiber架构的
3. 组件不同： React支持无状态组件
4. React的Concurrent模式对动画的支持比Vue更好
5. 事件处理方式不同， react基于合成事件，vue是基于snobdom为基础的virtual-dom的绑定事件的方式
6. 挂载的区别： Vue会覆盖掉挂载节点重新创建，react是挂载到挂载集诶单的内部



### Vue相关

#### 1. 简单说一下vue2的渲染过程

- New Vue创建实例，执行this._init方法， 合并属性，初始化状态，props, methods, 

  并设置代理

- $mount方法， 解析template，生成render函数

- mountComponent函数， 触发组件生命周期

- 创建watcher函数，第一次会创建渲染watcher

#### 2. vue2是如何进行数据更新的

#### 3. vue3是如何进行数据更新的



### 框架相关

#### 1. 能说一下dom diff的比对过程吗？

Dom diff就是将渲染前旧的virtual dom和即将渲染的新的virtual Dom做比对。(patch方法)

domdiff是一个递归的过程，以节点为单位比对

它主要有以下几个比对过程

1. 首先比较新节点和老节点的标签是否相同， 不相同直接替换

2. 如果新老节点的标签相同的话， 说明旧节点可以复用， 之后就去比对他们的属性。 

   进行更新属性操作

3. 比对完属性之后， 会比对他们的文本， 更新文本操作

4. 最后，会比对他们的孩子。 也是整个dom diff中的重点

   比对孩子的时候， 会采用一个双指针的比对方法， 即给新节点和旧节点的孩子设置一个头指针和尾指针。

   分别只想第一个孩子和最后一个孩子

5. 接下来使用一个while循环去进行比对。 不管是新节点还是旧节点， 只要有一个的头指针小于尾指针，就退出循环

6. 比对过程分为四种情况。 

   第一种正序结尾添加/删除

   比对新节点的头指针指向的节点和旧头指针指向的节点一样，依次往后移动新旧头指针， 当某一方的头指针大于尾指针的时候，

   退出循环，这时候另一方还有剩余，此时可以进行插入或者删除节点操作

   第二种情况开头添加删除

   这种情况依次发现新节点的头指针和老节点的头指针指向的节点不一样， 此时会去比对新节点的尾指针和就节点的尾指针

   如果一样， 依次让尾指针-1。 最后结束时， 发现剩余。进行新增或删除操作

   第三种情况倒叙

   这时候会发现新节点的头指针和旧节点的尾指针不一样， 新节点的尾指针和旧节点的尾指针也不一样。

   会用旧节点的头指针跟新节点的尾指针做比较， 如果一样， 那么吧旧节点头指针指向的节点移动到尾指针指向的节点后面

   旧头指针+1， 新尾指针-1.

   第四种情况。 无序。 使用key值找出位置。 进行移动

   ![image-20201129222235463](https://tva1.sinaimg.cn/large/0081Kckwly1gl7ceqlj53j31yk0ekq5c.jpg)



#### 2. Vue 的computed计算属性是如何实现缓存的

- 创建一个watcher实例，并传入`lazy: true`，包装computed的get方法computedGetter。

- 页面template使用fullName，触发fullName的getter方法，即包装好的getter方法computedGetter

- computedGetter方法中因为

  `watcher.dirty`为true，执行`watcher.evaluate`方法。

  - 在evaluate方法中，执行`this.value = this.get()`, 并把dirty设为false
  - 执行了get方法，即执行computedGetter方法，即执行computed的get方法，就会触发firstName和lastName的getter，从而把watcher收集进firstName和lastName的依赖中。

- 重新获取computed属性的值，即触发getter方法时，因为dirty已经为false，就从`watcher.value`取缓存值。

- 一旦firstName或者lastName发生变化，就会触发`watcher.update`方法，设置dirty为true。

- 重新获取computed属性的值，就会执行`watcher.evaluate`方法，重新计算，并改变缓存值。

缓存值存在哪里？

```
watcher.value
```



首先,computed本质也是一个watcher, 收集到响应式数据的dep属性中，通过Dep.target与属性进行关联。

初始化计算watcher的时候， lazy为true, 使用惰性求值。

之后使用该数据的时候， 调用`watcher.evaluate`方法触发到get方法， 会把dirty设置为false, 同时将计算出来的值

存到watcher.value中

如果依赖的值发生改变， 触发了setter，那么dirty会设置为false





### 前端模块化

#### 1. webpack的异步加载如何实现

1. 首先，如果在webpack中懒加载了一个模块， webpack会把这个懒加载模块打包成一个匿名函数的样子

   这个匿名函数呢，就是把当前的代码块push到window上的webpackJsonP中。

2. 需要加载这个模块的时候，webpack使用jsonP的方式对这个js进行加载，并且插入到html中

3. 改写数组原生的push方法， 将它指向**webpackJsonpCallback**这个方法

   这个函数的作用就是将已经加载过的模块在全局进行一个缓存。并且递归的调用父模块的这个方法

   进行依次缓存



#### 2. webpack的分包策略

- 新的 chunk 是否被共享或者是来自 node_modules 的模块
- 新的 chunk 体积在压缩之前是否大于 30kb
- 按需加载 chunk 的并发请求数量小于等于 5 个
- 页面初始加载时的并发请求数量小于等于 3 个



### 后端相关

#### 1. 简单说一下node的事件循环机制

node事件循环机制跟浏览器的循环机制类似， 都是先执行住县城的程序

遇到一步任务的时候， 会把当前的异步任务放到事件队列中， 

当主线程执行结束后， 依次按阶段执行清空异步任务队列。

区别就是异步队列的阶段不一样。

node的异步阶段主要有以下几部分： 

- timers: 主要是执行setTimeout和setInterval的回调函数

- Pending-callBacks: 上一次事件队列中没有执行结束的i/o操作

- Idle prepare: 内部系统使用

- Poll-轮训： i/o操作阶段， 可能会阻塞当前进行， 比如说在i/o操作里面嵌套了一些setTimeout， setImmediate。

- Check-检测阶段： 执行setImmediate

  ```js
  fs.readFile('./yueqi.txt', () => {
    setImmediate(() => {
      
    })
    
    setTimeout(() => {
      
    }, 0)
  })
  ```

备注： 

每个宏任务执行结束之后都会清空微任务队列



#### 2.Nginx的正向代理和反向代理

- 正向代理代理的是客户端， 服务端看不到真正的客户端， 例如使用公司内网访问外网

  ```shell
  server_name www.yueqi.com;
  resolver 8.8.8.8; # 谷歌的域名解析地址
  server {
    location / {
      proxy_pass http://$http_host$request_uri;
    }
  }
  ```

  

- 反向代理代理的是服务器端，客户端看不到真正的服务端。例如使用nginx代理应用服务器解决跨域

  ```shell
  location ~ ^/api {
    proxy_pass http://localhost:3000;
    proxy_redirect default; #重定向
    
    proxy_set_header Host $http_host; #向后传递头信息
    proxy_set_header X-Real-IP $remote_addr; #把真实IP传给应用服务器
  }
  
  ```

  



### 算法相关

#### 1.  给定一个字符串，你的任务是计算这个字符串中有多少个回文字符串。（具有不同开始位置或结束位置的字串，即使是由相同的字符组成，也会被视作不同的字串）

leetcode连接： https://leetcode-cn.com/problems/palindromic-substrings/

![image-20201129202123941](https://tva1.sinaimg.cn/large/0081Kckwly1gl7cerdh5zj30zj0bfmxu.jpg)

```js
function counSubstring(string) {
  if(!string) { return 0 }
  let arr = string.split('')
  let count = 0;
  
  for(let i=0; i < arr.length; i++) {
    for(let j=i; j < arr.length; j++) {
      if(isPland(s.substring(i, j+1))) {
        count ++
      }
    }
  }
  
  return count
}

function isPland(string) {
  let i = 0;
  let j = string.length - 1;
  
  while(i < j) {
    if(string[i] !== string[j]) {
      return false
    }
    i++;
    j--
  }
  
  return true
}
```



#### 2. 验证回文字符串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明：**本题中，我们将空字符串定义为有效的回文串。

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    // 正则去除非单词字符和下划线，然后转化为小写字符
    let str = s.replace(/(\W|_)/g, '').toLocaleLowerCase()
    // 下面就是用双指针判断是否是回文字符串的过程了
    let left = 0
    let right = str.length - 1
    while (left < right) {
        if (str[left] !== str[right]) {
            return false
        }
        left++
        right--
    }
    return true
}

```



#### 3. 求时针和分针的夹角

分析：

分针一圈走过的度数：

 360 / 12 * 5 = 6度

时针一圈走过的度数：

360 / 12 = 30度

所以如果分针在前， 那么夹角就是

6m - 30h

如果分针在后， 那么夹角就是

30h - 6m

但是这样存在误差， 需要计算一下时针每分钟走过的度数：

360 /（ 12 / 60 每分钟走过的度数） = 0.5度

所以最终

6m - (30h+0.5m) 或者 30h+0.5m - 6m



#### 3. 写一个方法计算Url中的参数

```js
// 解析Url中的参数
function parseParams(url) {
  if(!url) {
    return 
  }

  // 先拿到url参数
  let queryString = url.split('?')[1]
  // 设置结果集
  let params = {};

  // 依次拿到每个， 放入到结果集里面
  const queryArray = queryString.split('&')
  // ["a=1", "b=2"]
  queryArray.reduce((obj, kv) => {
    const [key, value] = kv.split('=');
    // 如果key是一个索引key， 进行处理

    depset(params, key.split(/[\[\]]/g).filter(x => x), value)

    console.log('path', key.split(/[\[\]]/g).filter(x => x))
    return params
  }, {})

  return params
}

function depset(params, path, value) {
  let i = 0;
  for(;i<path.length - 1; i++) {
    console.log('path', path[i])
    if(params[path[i]] === undefined) {
      if(path[i+1].match(/^\d+$/)) {
        params[path[i]] = []
      }else {
        params[path[i]] = {}
      }
    }

    params = params[path[i]]
  }

  params[path[i]] = decodeURIComponent(value)
}

let a = parseParams('www.baidu.com?a[0]=1&b[1]=2')
console.log(a)
```



#### 4. 大数相加

```js
function add(a, b) {
  a = a.split(''),
  b = b.split('');
  
  let sum = [];
  go = 0;
  
  while(a.length || b.length) {
    let num1 = parseInt(a.pop()) || 0;
    let num2 = parseInt(b.pop()) || 0;
	  let temp = num1 + num2 + go
    
    if(temp > 9) {
      temp %= 10
      go = 1
    }else {
      go = 0
    }
    sum.unshift(tmp)
  }
  
  if(go) {sum.unshift(1)}
  	
  return sum.join('')
}
```



#### 5. 如何安排最多的会议室



#### 6.  计算奖金最佳分配方式

我们进行了一次黑客马拉松大赛，全公司一共分为了N个组， 每组一个房间排成一排开始比赛，
 比赛结束后没有公布成绩，但是每个组能够看到自己相邻的两个组里比自己成绩低的组的成绩，
 比赛结束之后要发奖金，以1w为单位，每个组都至少会发1w的奖金，另外，如果一个组发现自己的奖金没有  高于比自己成绩低的组发的奖金，就会不满意，作为比赛的组织方，根据成绩计算出至少需要发多少奖金才能 让所有的组满意。

链接：https://www.nowcoder.com/discuss/509963?type=2&order=3&pos=17&page=1&channel=1009&source_id=discuss_tag





#### 7. 爬楼梯

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

连接： https://leetcode-cn.com/problems/climbing-stairs/

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n <= 2) { return n }
    let first = 1;
    let second = 2;
    

    for(let i = 3; i <= n; i++) {
        let third = first + second;
        first = second;
        second = third
    }

    return second
};
```





#### 8. 猴子吃香蕉

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。

珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

链接：https://leetcode-cn.com/problems/koko-eating-bananas

```js
/**
 * @param {number[]} piles
 * @param {number} H
 * @return {number}
 */

// 解题思路： 最少每次吃掉1跟， 最多每次吃掉最大堆数的一根。
// 计算每次吃到speed = 1+n，可否立刻吃完， 如果可以， 那么返回speed
var minEatingSpeed = function(piles, H) {
    let low = 1;
    let max = 1;

    for(let i = 0; i < piles.length; i++) {
        max = Math.max(piles[i], max)
    }

    let high = max


    // 计算总数
    while(low < high) {
        let mid = Math.floor((low + high)  / 2 )
        // 看当前的速度可不可以正好吃完
        let time = cucluteTime(piles, mid)
        console.log('time', time)
         // 说明吃不完，需要提高速度
        if(time > H) {
           low = mid + 1
        }else {
          // 说明可以吃完，但不是最小速度
          high = mid
        }
    }

    return low
};

// 计算事件与H比较
function cucluteTime(total, speed) {
    let time = 0

    for(pile of total) {
        // 3 3
        time += Math.ceil(pile / speed)
    }

    return time
}


// 速度 = 总数 / H
```



### Css相关

#### 1. bfc布局规则

BFC 即 块级格式化上下文（Block Formatting Contexts (）

具备BFC特性的的元素可以看作隔离的容器。容器里面的布局不会影响外面的布局

如何使用BFC:

- body 根元素
- 浮动元素：float 除 none 以外的值
- 绝对定位元素：position (absolute、fixed)
- display 为 inline-block、table-cells、flex
- overflow 除了 visible 以外的值 (hidden、auto、scroll)

BFC作用

1. 解决外间距重叠的问题， 块级元素的margin-top和margin-bottom会重叠
2. 可以包含浮动元素
3. BFC 可以阻止元素被浮动元素覆盖

